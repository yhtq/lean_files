import Init.Data.Nat.Basic
import Mathlib.Data.Nat.Factorization.Basic
import Mathlib.Data.Nat.Defs
import Mathlib.Tactic.Eval
import Batteries.Data.LazyList
import Mathlib.GroupTheory.Perm.Cycle.Type
import Mathlib.GroupTheory.Perm.Cycle.Concrete
import Mathlib.GroupTheory.Perm.Fin
import Mathlib.GroupTheory.SpecificGroups.Cyclic
import Mathlib.Logic.Equiv.Defs
import Mathlib.Tactic
open Classical
open Fintype
open Subgroup

section E_1264
example {G : Type*}[Group G] [Fintype G] :  Group.FG G:= by exact Group.fg_of_finite
--1. $Problem \ A$ ,we find the same in Mathlib, if we want to prove it, just need G is generated by itself.
instance : AddGroup.FG ℤ := by
--2. $Problem \ B$ ,we can easily find that that $\Z$ is generated (additively) by $\left \langle 1 \right \rangle $, which card is one.
  apply AddGroup.fg_iff'.mpr
  use 1
  -- the card of $\left \langle 1 \right \rangle $ is 1
  use {1}
  -- find that that $\Z$ is generated (additively) by $\left \langle 1 \right \rangle $
  constructor
  · rfl
    --prove its card is 1
  · apply AddSubgroup.closure_eq_of_le
    --trun the Finset.generated into one elements's zmultiples
    · simp only [Finset.coe_singleton, AddSubgroup.coe_top, Set.subset_univ]
    · simp only [Finset.coe_singleton, top_le_iff]
      rw[← AddSubgroup.zmultiples_eq_closure]
      simp only [Int.zmultiples_one]

instance Q_FG (Qg : AddSubgroup ℚ) (hfg :Qg.FG ) : IsAddCyclic Qg := by
  rcases hfg with ⟨Qfs, hQfs⟩
  let Sn := Qfs.prod Rat.den
  let f : ℚ -> ℤ :=  fun x => Sn * x.num / x.den
  let Zfs := Qfs.image f
  let Zg := AddSubgroup.closure Zfs.toSet
  rcases Int.subgroup_cyclic Zg with ⟨Ze, hZe⟩
  rw[← AddSubgroup.zmultiples_eq_closure] at hZe
  have Ze_in : Ze ∈ Zg := by
   rw [hZe]
   apply AddSubgroup.mem_zmultiples
  have Zg_cyc : IsAddCyclic Zg := inferInstance
   --这里不知道为什么不对？ 因为Int.subgroup_cyclic 就已经可以说明是循环群了？？？
  let f' : Zg -> Qg := fun z => z / Sn
  --have hf' : f'.Surjective := by sorry
  --apply isCyclic_of_surjective f'
  --这里我想说能构建一个满射出来就可以直接得到Qg也是循环的，我觉得应该是Zg中的元素除以Sn就好了但是不知道为什么也是有问题的








lemma cyc_trans  {G: Type*} [AddGroup G] ( h: IsAddCyclic (⊤: AddSubgroup G)): IsAddCyclic G := by
 let f : (⊤ : AddSubgroup G)≃+ G  := AddSubgroup.topEquiv
 apply isAddCyclic_of_surjective f (AddEquiv.surjective f)

instance : ¬AddGroup.FG ℚ :=by
  by_contra hQ_FG
  have htop_FG :  (⊤: AddSubgroup ℚ).FG := by apply AddGroup.fg_def.mp hQ_FG
  have htop_cyc : IsAddCyclic (⊤: AddSubgroup ℚ) :=by apply (Q_FG (⊤: AddSubgroup ℚ) htop_FG)
  have hQ_cyc : IsAddCyclic ℚ :=by
   apply cyc_trans
   exact htop_cyc

  rcases hQ_cyc with ⟨Qe, hQ_e⟩
  absurd hQ_e
  push_neg
  by_cases Qe_pos : Qe = 0
  · use 1/2
    rw[Qe_pos]
    by_contra hQe
    rcases hQe with ⟨n , hn ⟩
    absurd hn
    push_neg
    simp only [smul_zero, one_div, ne_eq, zero_eq_inv, OfNat.zero_ne_ofNat, not_false_eq_true]
  ·
    use Qe/2
    by_contra hQe
    rcases hQe with ⟨n,hn⟩
    push_neg at Qe_pos
    ring_nf at hn
    rw[zsmul_eq_mul]at hn
    nth_rw 2 [mul_comm] at hn
    apply mul_right_cancel₀ Qe_pos at hn
    field_simp at hn
    have hn_z : n * 2 = 1 := by
      qify
      rw[hn]
    have h_even_1 : Even (1:ℤ)  := by
      use n
      rw[← hn_z]
      ring_nf
    absurd h_even_1
    simp only [Int.not_even_one, not_false_eq_true]

end E_1264
